\section{Исполняемые файлы. Загрузчики}

\subsection{Стадии компиляции}

\begin{itemize}
	\item Получить бинарный код из исходного кода. 
	\item Сделать из этого \textbf{исполняемый файл}.
\end{itemize}

 \subsection{x86 Форматы исполняемых файлов}
 
 \begin{itemize}
 	\item Простой бинарник. Никаких заголовков, только код с нулевым отступом.
 	\item ELF (UNIXes)
 	\item EXE (Windows)
 \end{itemize}

\subsection{ELF}

\begin{itemize}
	\item \textbf{Магические байты}: {0x7F, 'E', 'L', 'F'}
	\item \textbf{Бинарный заголовок}:
		\begin{itemize}
			\item архитектура процессора
			\item разрядность процессора
			\item точка входа
			\item позиции сегментов
		\end{itemize}
\end{itemize}

\subsection{Интерпретатор ELF файлов}

Специальная программа (/lib[64]/ld-linux.so) для загрузки программы в память. 
Она нужна, чтобы:
\begin{itemize}
	\item Загружает сам файл память и все требуемые библиотеки.
	\item Аллоцирует память на стек.
	\item Прыгает на точку входа программы.
\end{itemize}

\subsection{Динамическая библиотека vs Исполняемый файл}

\begin{itemize}
	\item Тот же самый ELF формат
	\item У исполняемого файла должна быть точка входа.
	\item У библиотеки должна быть таблица символов.
\end{itemize}

Команда ld линкует библиотеки.

\begin{Def}
	\underline{Позиционно независимый код} --- код, который может быть загружен в произвольную область памяти. Его можно получиться с помощью опции -fPIC у gcc.
\end{Def}

\subsection{Flat-form файл}

\begin{itemize}
	\item Нет заголовков.
	\item Для запуска достаточно просто перейти на начало файла.
	\item Последняя инструкция должна быть ret.
\end{itemize}

\subsection{Загрузчик ядра}

Этапы работы загрузчика:
\begin{itemize}
	\item Найти ядро на диске.
	\item Загрузить его и разместить в памяти.
	\item Запустить ядро.
\end{itemize}

\subsection{Классический загрузчик}

\begin{itemize}
	\item BIOS определяет порядок дисков загрузки.
	\item На дисках проверяются первые 512 байт содержимого, \textbf{главная загрузочная запись} (master boot record). Она содержит:
		\begin{itemize}
			\item Диск является загрузочным, если последние байты 0x55 или 0xAA.
			\item 64 байта содержат основную таблицу разделов.
			\item 446 байт содержат исполняемый код загрузчика. 
		\end{itemize}
\end{itemize}

\subsection{Условия работы загрузчика}

\begin{itemize}
	\item Процессор находится в реальном режиме работы.
	\item Может общаться с видеопамятью напрямую.
	\item Могут использовать функциональность BIOS для работы с:
		\begin{itemize}
			\item дисками
			\item клавиатурой
			\item COM-портами
		\end{itemize}
\end{itemize}

\subsection{Обзор загрузчиков}

\begin{itemize}
	\item Простые: ntldr (Windows), loadlin (Linux)
	\item Универсальный: GRUB
		\begin{itemize}
			\item Умеет загружать все операционные системы
			\item Выбор ОС и опций загрузки
			\item Красивый графический фон
		\end{itemize}
\end{itemize}

\textbf{А как код GRUB умещается в эти 446 байт?}
Ответ --- никак. На самом деле код разбит на модули, которые подгружаются после
основного кода по необходимости.

\subsection{Загрузка ELF снимка}

\begin{itemize}
	\item Переключение в 24-битный режим адресации памяти
	\item Загрузка файла ядра с диска и размещение его строго после 1Мб 
	в адресном пространстве. 
	\item Найти магические байты GRUB в снимке ядра. Точка входа располагается рядом
	с этими магическими байтами.
	\item Отключаем прерывания.
	\item Переключаемся в защищенный режим.
	\item Запуск!
\end{itemize}

В ноутбуках, особенно ультрабуках, чаще используется другой подход:
\subsection{GUID Таблица разметки}

Каждый диск получает уникальный 128-битный ключ.

Сейчас для разработки загрузчиков используют более высокоуровневую вещь --- 
UEFI API (Unified Extensible Firmware Interface)

