\section{Способы ускорения выполнения кода}

\subsection{SRAM (Static RAM)}

\begin{itemize}
	\item Время чтения - 1 такт
	\item Время записи - 2 такта
	\item Тактовая частота зависит от размеров транзистора
\end{itemize}

\subsection{DRAM (Dynamic RAM)}

\begin{itemize}
	\item 1 транзистор + 1 конденсатор
	\item Конденстатор требует перезарядки после каждого чтения
	\item Чтение/запись занимают много времени
	\item Периодическая регенерация (каждый 64 нс) из-за утечек
\end{itemize}

\subsection{DRAM vs SRAM}

Если вы делаете какую-то схему на базе микроконтроллеров и вам не требуется больших
обьемов памяти, намного проще использовать SRAM. Размер памяти в SRAM измеряется порядками
Кб, Мб на каждую схемку.

\subsection{Локальность доступа}

Иногда у вас есть нужен небольшой кусок данных, которые вы часто используете. Хочется 
иметь к нему быстрый доступ. Такая память называется кэш.

\subsection{Информация о кэше в Linux}

\begin{Def}
	\underline{Кэш} --- это память, размер которой меньше размера всей памяти, который вы
	можете адресовать. Он работает намного быстрее и хранит нужный вам кусок.
\end{Def}

Информацию о кэшах в вашем компьютере можно посмотреть в каталоге
/sys/devices/system/cpu/cpu0/cache

\subsection{Уровни кэша (в x86)}

\begin{itemize}
	\item \textbf{L1 (index0 + index1)}  --- самый близкий кэш микроинструкций и текущий данных,
	с которыми оперирую микроинструкции.
	\item \textbf{L2} --- общий кэш, связанный с ограниченным количеством ядер (обычно одним).
	\item \textbf{L3} --- общий кэш, связанный со всеми ядрами.
\end{itemize}

\subsection{Ключевая проблема}

Размер кэша очень маленький. Вся память в несколько Гб нельзя упихать в несколько Мб.

\subsection{Причины кэш-промахов}

\begin{Def}
	\underline{Кэш-промах} --- это когда вы обращаетесь к какому-то участку памяти, который
	отсутствует в памяти.
\end{Def}

\begin{itemize}
	\item Первое обращение к определенной области памяти
	\item Данные были выгружены из-за ограниченного размера кэша.
	\item Данные были выгружены из-за ограниченной ассоциативности. Если обращаться 
	к данным в рандомном порядке, процессор не догадается, какие из них надо закэшировать.
\end{itemize}

\subsection{Как устроен кэш}

\begin{Def}
	\underline{Блок} --- минимальный адресуемый обьем данных в кэше. Это 64 байта для Intel.
\end{Def}

\begin{Def}
	\underline{Кэш-линия} --- блок + метаданные, определяющие адрес в памяти.
\end{Def}

\begin{Def}
	\underline{Набор} --- связан с некоторым адресом в оперативной памяти. Для L3 --- 12 
	линий по 64 байта = 768 байт.
\end{Def}

Кэш состоит из независимых наборов. Для Core i5/Gen10 размер кэша L3 6Мб = 64 байта в блоке *
12 линий в наборе * 8192 наборов.

\subsection{Что значит Cache-Friendly}

\begin{itemize}
	\item По возможности использовать непрерывные блоки данных.
	\item Выравнивать данные по границе кэш-линии: Alignas(64) в Си.
\end{itemize}

\subsection{Как использовать кэш?}

\begin{itemize}
	\item Нет команд, которые бы управляли кэшем. Нельзя програмно положить 
	что-то в кэш.
	\item Компиляторы Си/С++ и пр. могут генерировать код для предзагрузки данных.
	\item Увеличить вероятность попадания в кэш можно размещая данные последовательно.
\end{itemize}

\subsection{Профилирование}

Исследовать программу на производительность можно с помощью команды 
valgrind --tool=cachegrind ПРОГ [АРГ0][... АРГn]

\subsection{Стадии выполнения команд}

Современные процессоры являются \textbf{суперскалярными}. Это означает, что они не обязательно
выполняют команды строго последовательно.

Существуют следующие стадии выполнения команд:
\begin{itemize}
	\item Instruction Fetch
	\item Instruction Decode
	\item Execute
	\item Memory Access
	\item Register Write Back 
\end{itemize}

Каждая стадия задействует отдельные блоки процессора, которые слабо связаны между собой. Поэтому можно начинать выполнять следующую команду даже если не закончили выполнение предыдущей. Такой способ выполнения называет \textbf{конвейеризацией выполнения}.

\subsection{Сверхдлинные конвейеры}

С одной стороны это круто, потому что можно хорошо распараллеливать исполнение команд.
Но в случае условных инструкций длинный ковейер придется долго откатывать.

У современных процессоров длина конвейера - 8...15. 

\subsection{Идея спекулятивного выполнения}

\begin{itemize}
	\item В случае условного выполнения вычисляем сразу обе ветки. Если не угадали ветку, результат просто отбрасываем.
	\item Компилятор может переставлять процессорные инструкции местами, если это не
	вляет на результат.
\end{itemize}

\subsection{Векторные инструкции}

 Было на семах.








