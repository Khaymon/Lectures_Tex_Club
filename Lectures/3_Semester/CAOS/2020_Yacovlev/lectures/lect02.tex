\section{Введение в Unix системы}

\subsection{Пользовательская сессия}

\begin{Def}
	\underline{Пользователь} --- это некоторое целое число, UID. У него даже может не быть имени.
\end{Def}

Пользователи могут обьединяться в \textbf{группы}. Причем один пользователь может быть в нескольких группах. Группы нужны, чтобы организовывать совместный доступ к файлам и другим ресурсам.

Авторизация пользователя:
\begin{itemize}
	\item Текстовый вход (TTY console)
    \item Графический вход (sddm, kdm, gdm)
    \item Удаленное подключение (ssh, telnet)
\end{itemize}


Расширить права введением пароля:
\begin{itemize}
	\item su и sudo
	\item графические настройки
\end{itemize}


\subsection{Подключаемые модули аунтефикации (\texttt{PAM})}

\begin{Def}
	\underline{\texttt{PAM}} - это набор библиотек, которые предоставляют API для авторизации пользователя и
	проверки прав.
\end{Def}


Способы авторизации:
\begin{itemize}
	\item \underline{/etc/passwd и /etc/shadow/}
	
	Информацию о пользователях можно найти в файле \textbf{/etc/passwd}. Там для каждого пользователя
	указаны имя пользователя, UID, группы пользователей, полное имя, путь до домашнего каталога и используемый интерпретатор.
	
	\textbf{!Некоторые пользователи впринципе не могут войти в систему.} /sbin/nologin --- тот shell, который сразу после входа моментально разлогонивает пользователя. Это нужно для того, чтобы иметь виртуальных пользователей. То есть преднозначенных для выполнения ровно одного процесса.
	
	Пароли хранятся в файле \textbf{/etc/shadow/} в хешированном виде.
	
	\item \underline{Биометрия} 
	
	\textbf{Возможена авторизация не только по паролю.} Можно также, например, по отпечатку пальца 
	или по инфракрасной камере. Хотя многие бытовые ноутбуки последних годов выпуска не
	имеют драйверов под Linux, поэтому с этим возникают проблемы.
	
	\item \underline{LDAP сервис}

	Если есть большое количество компьтерных организаций, то удобно \textbf{хранить все данные о пользователях централизованно}. В Unix системах для этого используется LDAP сервис.
\end{itemize}


\subsection{Создание пользователей}

Конечно, в графическом режиме можно зайти в настройки и нажать кнопочку добавить пользователя. Но как это сделать, если мы находимся на удаленном сервере?

Инструменты для создания пользователей:
\begin{itemize}
	\item \texttt{useradd} - стандартная Linux команда. Ей достаточно передать параметры пользователя.
	\item \texttt{adduser} - интерактивный инструмент командной строки. Shell скрипт, которым позволяет сделать useradd в интерактивном режиме.
\end{itemize}

Параметры создания пользователя:
\begin{itemize}
	\item Имя, группы, пароль, {shell}
	\item Изначальный контент домашней директории (обычно копируется из \texttt{/etc/skel})
\end{itemize}

В \texttt{/etc/skel} в основном хранятся настройки пользователя:
\begin{itemize}
	\item \textbf{.profile} - настройки отдельного пользователя, включая переменные окружения
	\item \textbf{.bashrc} - настройки командного интерпретатора bash.
\end{itemize}

\subsection{Пользователь залогинился. Что дальше?}

У каждого пользователя есть свой \texttt{shell}. 

\begin{Def}
	\underline{\texttt{Shell} пользователя} --- это команда, которая исполняется при логине пользователя. Ее можно найти в \texttt{/etc/passwd}
\end{Def}

Shell программа инициализирует переменные окружения из \texttt{$\sim$/.profile} и \texttt{$\sim$/.bashrc}.

Общие для всех пользователей переменные могут быть указаны в \texttt{/etc/profile} и /\texttt{etc/bashrc}.

\subsection{Более подробно про интерпретаторы \texttt{shell}'a} 

\begin{itemize}
	\item самодостаточный \texttt{shell} program: \textbf{FreeBSD}
	\item основной в \texttt{Linux}: \textbf{bash}
	\item debian: \textbf{dash}
	\item alpine: \textbf{busybox}
	\item maxOS X: \textbf{zsh}
\end{itemize}

\subsubsection{zsh} используется в macOS с недавнего времени по лицензионным соображениям. 
Также его используют и некоторые пользователи Linux из \textit{соображений безопасности}, поскольку поддерживает некоторую дополнительную функциональность. Например, запрет на принципы переноса строки при копировании. Это контролируется, чтобы случайно не выполнить потенциально опасную команду. 

\subsubsection{bash} наиболее распространенный. У него есть много модулей для автодополнения.

\subsubsection{busybox и dash} Более простые. Кстати, у busybox есть своя особенность: в Alpine Linux все стандартные линуксовые команды являются символическими ссылками на некоторый файл busybox размером 800КБ. 

\begin{Def}
	\underline{Busybox} --- это один большой бинарник, который в зависимости от именни программы, которую запускают, выполняет разную функциональность.
\end{Def}

В системе \texttt{Android}, которая является Linux, тоже используется \texttt{busybox}. Такой подход нужен, чтобы \textbf{уменьшить количество программ и сэкономить место на диске}. Многие программы имеют дублирующую функциональность (например, разбор аргументов командной строки), поэтому логично сделать одну большую программу, которая ведет себя по-разному в зависимости от того, с каким именем вызывается.

\subsection{Переменные окружения}

\begin{itemize}
  \item \textbf{PATH} --- Тут прописано, \textit{где можно искать файлы}, которые вы запускаете без указания полного пути 
 
(PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin)
  \item \textbf{EDITOR} --- \textit{редактор по умолчанию.} Например, он вызывается при git commit. (EDITOR=emacs)
  \item \textbf{LANG} --- нужна, чтобы понять, на каком языке реализовывать интерфейс пользователя.
  \item \textbf{LC\_ALL} --- описывает, какую локаль использовать.
\end{itemize}


\subsubsection{Принципиальное отличие между LANG и LC\_ALL} \texttt{LANG} используется прикладными приложениями и \textbf{высокоуровневыми фреймворками} для того, чтобы понять, на каком языке отображать интерфейс. \texttt{LC\_ALL} используется \textbf{стандартной С библиотекой}. В частности, в функциях ввода/вывода, форматировании дат и т.д. То есть это более \textbf{низкоуровневая} вещь.

\subsubsection{Сокращения (Aliases)}
alias ..='cd ..' \\
alias ды='ls'


Если вы обьявили переменную, она существует в рамках того \texttt{shell}, который сейчас запущен. Как только \texttt{shell} завершит свою работу или запустит дочерние процесс, никому эти переменные не будут известны. Команда \textbf{export} говорит, что эта \textit{переменная должна быть доступна \textbf{всем} дочерним процессам}, а не только в текущем сеансе. 


\subsection{Текстовые кодировки}

Есть два способа кодирования символов:
\begin{itemize}
	\item Использовать несколько байт на один символ (wchar\_t, std::wstring). 
	\item Последовательность байт (char, std::string).
\end{itemize}

\subsubsection{Пример: Русский язык}

\begin{itemize}
	\item \texttt{ANSI (7 bits)}: только US/UK Английский язык
	\item \texttt{KOI8-R и KOI8-U}: один бит для переключения языка
	\item \texttt{OEM Encoding}: поддержка на уровне <<железа>>
	\item \texttt{ANSI Encoding}: все символы кириллицы от Microsoft.
\end{itemize}

\subsection{UTF-8}

\begin{Def}
	\underline{UTF-8} --- универсальный способ, который \textbf{покрывает все языки} и при этом является \textbf{обратно совместимым} с кодировкой \texttt{ASCII}. Сейчас стал стандартном как в интернете, так и в написании исходных текстов.
\end{Def} 

\subsubsection{В чем идея?}

Если старший бит равен 0, то младшие 7 бит в точности совпадают с кодом символов в кодировке \texttt{ASCII}.

Если есть символы, которые не покрываются \texttt{ASCII}, то они кодируются последовательностью байт, где в старших байтах каждый из байт --- единица. 

Большинство европейских символов покрываются 2-мя байтами на один символ. Азиатские --- 3 байта на символ. Смайлики, эмодзи --- 4 байта на символ. 

\subsection{Вход пользователя}

\begin{itemize}
	\item Login + shell
	\item startx + xinitrc \textcolor{gray}{// что-то из 90-х ...}
\end{itemize}

В современных системах, если это не серверная конфигурация, сразу запускается сеанс с графическим рабочим столом.

\underline{Графическая сессия состоит из:}
\begin{itemize}
	\item \textbf{X11 сервер}: отвечает за взаимодействие с видеокартой, клавиатурой и всем остальным.
	\item \textbf{Менеджер дисплея}: отвечает за авторизацию пользователя, ввод пароля и запуск нужного сеанса.
	\item \textbf{Менеджер окон}: отвечает за отрисовку окон и управлением жизненных циклов процессов.
	\item \textbf{Приложение рабочего стола}: приложение, которое рисует рабочий стол
\end{itemize}

\subsection{X сервер}

\begin{Def}
	\underline{Сервер} --- это процесс, который принимает входящие подключения (от одного или нескольких клиентов) и как-то их обрабатывает.
\end{Def}

\begin{Def}
	\underline{X cервер} --- это некоторая программа, которая имеет доступ к видеокарте, клавиатуре, мыши.
\end{Def}

Когда мы запускаем некоторое графическое приложение, оно устанавливает соединение через локальный сокет с сервером \texttt{DISPLAY}. 

В переменной окружения \texttt{DISPLAY} указан адрес сервера, номер терминала (DISPLAY=:0.0 значит, что к \texttt{DISPLAY} можно подключиться по адресу \texttt{localhost}, номер терминала -- 0).

Соединение можно пробросить через протокол ssh:
\texttt{ssh \textbf{-X} user@hostname}

\subsection{Приложения}

Приложения - это некоторые пакеты:
\begin{itemize}
	\item \textbf{обычные архивы} (FreeBSD)
	\item \textbf{RPM} (rpm to install, rpmbuild to build)
	\item \textbf{DEV} (dpkg to install, debuild to build)
\end{itemize}

Пакеты:
\begin{itemize}
	\item Набор файлов
	\item {Установочные} скрипты и скрипты {деинсталяции}.
	\item {Метаинформация}: название, версия, описание, {зависимости}
\end{itemize}

Пакеты зависят друг от друга:
\begin{itemize}
	\item {Библиотеки конкретных версий}
	\item Продукт может быть разбит на {несколько частей}: отдельные части под конкретные архитектуры и общие для всех архитектур.
\end{itemize}

Для того, чтобы управлять зависимостями и скачивать пакеты из удаленных репозиториев существуют \textbf{пакетные менеджеры}:
\begin{itemize}
	\item \textbf{apt-get} (apt) для Debian/Ubuntu (dpkg)
	\item \textbf{yum} (dnf) для Fedora (rpm)
	\item \textbf{apt-get} для AltLinux (rpm)
\end{itemize}

\subsection{Установка из исходного кода}
Большинство программ в Linux имеют открытый исходный код. 
Исходный код запаковывают в архивы. 
Исходный код требует каких-то дополнительных библиотек.
Стандартный способ установки: 

	./configure \\
	make  \\
	make install \\

Иерархия каталогов:
\begin{enumerate}
	\item \textbf{Корневой каталог /} имеет bin, lib, ...
	\item \textbf{/usr} директория имеет очень похожую структуру
	\item \textbf{/usr/local} содержит кастомные конфигурации. То есть то, что не покрывается софтом, установленным из пакетов.
\end{enumerate}

Такая структура имеет исторические причины. В старых UNIX-системах была привязка к железу. Обычно был один маленький, быстрый диск и другой, большой, но медленнее. Большой монтировался к \texttt{/usr}.

\subsubsection{Как сейчас устроено распределение?} 

\begin{itemize}
  \item Основной каталог --- \texttt{/usr}

\item В корневой каталог помещается все, что востребовано в качестве минимальной системы. То есть это минимальный набор файлов, чтобы посмотреть состояние системы, список файлов, что-то подмонтировать и т.д.

Хотя в некоторых дистрибутивах, например, Fedora, \texttt{/bin} и \texttt{/lib} являются просто символическими ссылками на соответствующие разделы \texttt{/usr}. При этом если вы запускаете какую-то утилиту, то \textbf{поиск происходит от корня в глубину}. То есть сначала /bin, потом /usr/bin, а уже затем - /usr/local/bin. Поэтому чтобы запустить правильную версию, надо либо указать полный путь к программе, либо поменять переменную \texttt{PATH}.
\end{itemize}

\subsection{Исполняемые файлы и библиотеки}

\begin{enumerate}
	\item \textbf{Статические библиотеки}
		\begin{itemize}
			\item Индексированный архив обьектных файлов
			\item Сейчас редко используются
		\end{itemize}
	\item \textbf{Динамические библиотеки}
		\begin{itemize}
			\item Как обычные исполняемые файлы
			\item Нет точки входа
			\item Есть таблица символов
		\end{itemize}
\end{enumerate}


\subsection{Генерация Makefile'ов}

\textbf{Зачем нужны конфигурационные скрипты?} Почему бы в поставке софта не использовать сразу готовый Makefile? Синтаксис Makefile'ов может сильно отличаться. Кроме того, необходимые нам библиотеки могут располагаться в разных путях.

Решения:
\begin{itemize}
	\item \textbf{./configure script}: требует только shell и базовые инструменты, но трудно поддерживать (решение для этого: \texttt{autotools})
	\item \textbf{qmake/jam/scons/custom scripts}: обычно привязаны к конкретному фреймворку.
	\item \textbf{cmake}
\end{itemize}

\subsection{CMake}

Это универсальный \texttt{C} и \texttt{С++} инструмент для генерации \texttt{makefiles}. 
Имеет много вспомогательных модулей для пакетов с открытым исходным кодом. 

\subsection{Распространение софта}

\begin{itemize}
	\item Предоставить файлы для компиляции: ./configure, CMakeLists.txt, ...
	\item Предоставить ./debian/ файлы (debuild) для Ubuntu/Debian
	\item Предоставить package.spec (rpmbuild) для разных дистрибутивов
	\item \href{https://launchpad.net}{Ubuntu LaunchPad}
	\item \href{https://build.opensuse.org}{openSUSE Build Service}
\end{itemize}

