\section{Языки ассемблера и двоичный код}

\subsection{Стадии трансляции}

\begin{itemize}
	\item \textbf{Препроцессинг текста.} На выходе - текст.
	\item \textbf{Абстрактное дерево синтаксического разбора} и таблицы символов. Формат этого дерева внутренний, зависит от договоренностей.
	\item \textbf{Код на языке ассемблера или двоичный код.}
\end{itemize}

\subsection{Языки ассемблера}

\begin{itemize}
	\item Линейная последовательность команд
	\item Нет вложенных конструкций
	\item Нет вычислимых выражений. Точнее бывает, но только с константами и
	это обрабатывается на стадии препроцессинга (syntax sugar).
	\item Текст распознается регулярным выражением, а не контекстно-свободной грамматикой.
\end{itemize}

Любую программу языка ассемблера можно скомпилировать, а потом выполнить обратную 
операции - дизасемблирование. При этом код программы будет почти в точности совпадать. 

\subsection{Кодирование команд}

Есть две процессорные архитектуры:
\begin{itemize}
	\item \textbf{RISC.} Каждая команда длинной в машинное слово. Поэтому зная 
	начало кода можно извлечь любую инструкцию.
	\item \textbf{CISC.} Одна команда - произвольное количество байт.
\end{itemize}

\subsection{Команды и регистры}

\begin{itemize}
	\item Почти всегда процессор умеет выполнять действия только над регистрами. 
	\item Регистр - это не просто быстрая память. Это память, к которой процессор
	обращается напрямую.
	\item Доступ к памяти  - достаточно сложная операция.
	\item Некоторый процессоры (например, x86) имеют команды для адресации памяти, но на самом деле они сводятся к загрузке этой памяти в регистры.
\end{itemize}

\subsection{Кодирование команд}

В команде кодируется:
\begin{itemize}
	\item Какая именно команда
	\item C какими регистрами она работает
	\item Константы. При этом, не все константы можно закодировать
	в команде, потому что их слишком много. 
\end{itemize}

\subsection{Ключевая проблема}

Нельзя впихнуть невпихимуемое. Длина команды - всего 32 бита.

Как закодировать адрес? Очевидно, нельзя адресовать все виртуальное адресное пространство,
ведь это 4ГБ, а у нас есть всего 12 бит на кодирование адреса. \

Поэтому код команды устроен так: 8 бит на значение и 4 бита на сдвиг с вращением. С помощью этого можно закодировать наиболее часто используемые адреса.

\subsection{Procedure Linkage Table}

Библиотечные функции находятся далько от нашего коде в адресном пространстве. Поэтому
возникает проблема с тем, чтобы вызвать эту функцию, ведь как было показано выше, мы не
можем закодировать в команде произвольный адрес перехода. Эту проблему решает Procedure Linkage Table. 

\begin{Def}
	\underline{Procedure Linkage Table} --- это таблица в памяти, рядом с исполняемым кодом, где записаны реальные адреса библиотечных функций. Это позволяет вызвать библиотечную функцию, которая находится далеко в адресном пространстве.
\end{Def}

\subsection{Про кодирование команд}

У ARM есть расширения:
\begin{itemize}
	\item \textbf{Thumb.} 16 битные инструкции
	\item \textbf{Jazelle.} Декодирование байткода Java. Раньше было полезно, 
	чтобы запускать игрушки на слабых телефонах.
\end{itemize}

\subsection{Уровни абстракции}

\begin{itemize}
	\item Высокоуровневый язык
	\item Промежуточный язык
		\begin{itemize}
			\item байткод (Java, CLI или PyPy)
			\item LLVM - абстракция от ассемблеров разных архитектур
		\end{itemize}
	\item Язык ассемблера
	\item Двоичный код
\end{itemize}

\subsection{Зачем понимать кодирование команд}

\begin{itemize}
	\item Just-In-Time компиляция
	\item Эмулятор компьютерной системы
	\item Трансляция команд
\end{itemize}

